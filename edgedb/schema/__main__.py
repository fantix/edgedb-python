import argparse
import importlib
import inspect
import os
import pathlib
import sys
from types import ModuleType
from typing import Optional, Dict, List

try:
    from mypy import stubgenc
except ImportError:
    print('Error: cannot import mypy. Consider "pip install mypy".', file=sys.stderr)
    sys.exit(1)

from . import EdgeDBModuleImporter
from ..blocking_con import connect


def is_skipped_attribute(attr: str) -> bool:
    return attr in (
        "__getattribute__",
        "__str__",
        "__repr__",
        "__doc__",
        "__dict__",
        "__module__",
        "__weakref__",
    )  # For pickling


def generate_c_type_stub(
    module: ModuleType,
    class_name: str,
    obj: type,
    output: List[str],
    imports: List[str],
    sigs: Optional[Dict[str, str]] = None,
    class_sigs: Optional[Dict[str, str]] = None,
) -> None:
    """Generate stub for a single class using runtime introspection.

    The result lines will be appended to 'output'. If necessary, any
    required names will be added to 'imports'.
    """
    # typeshed gives obj.__dict__ the not quite correct type Dict[str, Any]
    # (it could be a mappingproxy!), which makes mypyc mad, so obfuscate it.
    obj_dict = getattr(obj, "__dict__")  # type: Mapping[str, Any]  # noqa
    items = sorted(obj_dict.items(), key=lambda x: stubgenc.method_name_sort_key(x[0]))
    methods = []  # type: List[str]
    properties = []  # type: List[str]
    done = set()  # type: Set[str]
    for attr, value in items:
        if stubgenc.is_c_method(value) or stubgenc.is_c_classmethod(value):
            done.add(attr)
            if not is_skipped_attribute(attr):
                if attr == "__new__":
                    # TODO: We should support __new__.
                    if "__init__" in obj_dict:
                        # Avoid duplicate functions if both are present.
                        # But is there any case where .__new__() has a
                        # better signature than __init__() ?
                        continue
                    attr = "__init__"
                if stubgenc.is_c_classmethod(value):
                    methods.append("@classmethod")
                    self_var = "cls"
                else:
                    self_var = "self"
                stubgenc.generate_c_function_stub(
                    module,
                    attr,
                    value,
                    methods,
                    imports=imports,
                    self_var=self_var,
                    sigs=sigs,
                    class_name=class_name,
                    class_sigs=class_sigs,
                )
        elif stubgenc.is_c_property(value):
            done.add(attr)
            stubgenc.generate_c_property_stub(
                attr, value, properties, stubgenc.is_c_property_readonly(value)
            )

        elif attr in obj.__annotations__:
            done.add(attr)
            properties.append(
                "%s: %s = ..." % (attr, obj.__annotations__[attr].__name__)
            )

    variables = []
    for attr, value in items:
        if stubgenc.is_skipped_attribute(attr):
            continue
        if attr not in done:
            variables.append("%s: Any = ..." % attr)
    all_bases = obj.mro()
    if all_bases[-1] is object:
        # TODO: Is this always object?
        del all_bases[-1]
    # remove pybind11_object. All classes generated by pybind11 have pybind11_object in their MRO,
    # which only overrides a few functions in object type
    if all_bases and all_bases[-1].__name__ == "pybind11_object":
        del all_bases[-1]
    # remove the class itself
    all_bases = all_bases[1:]
    # Remove base classes of other bases as redundant.
    bases = []  # type: List[type]
    for base in all_bases:
        if not any(issubclass(b, base) for b in bases):
            bases.append(base)
    if bases:
        bases_str = "(%s)" % ", ".join(
            stubgenc.strip_or_import(stubgenc.get_type_fullname(base), module, imports)
            for base in bases
        )
    else:
        bases_str = ""
    if not methods and not variables and not properties:
        output.append("class %s%s: ..." % (class_name, bases_str))
    else:
        output.append("class %s%s:" % (class_name, bases_str))
        for variable in variables:
            output.append("    %s" % variable)
        for method in methods:
            output.append("    %s" % method)
        for prop in properties:
            output.append("    %s" % prop)


def generate_stub_for_c_module(
    module_name: str,
    target: str,
    sigs: Optional[Dict[str, str]] = None,
    class_sigs: Optional[Dict[str, str]] = None,
) -> None:
    """Generate stub for C module.

    This combines simple runtime introspection (looking for docstrings and attributes
    with simple builtin types) and signatures inferred from .rst documentation (if given).

    If directory for target doesn't exist it will be created. Existing stub
    will be overwritten.
    """
    module = importlib.import_module(module_name)
    assert stubgenc.is_c_module(module), "%s is not a C module" % module_name
    subdir = os.path.dirname(target)
    if subdir and not os.path.isdir(subdir):
        os.makedirs(subdir)
    imports = []  # type: List[str]
    functions = []  # type: List[str]
    done = set()
    items = sorted(module.__dict__.items(), key=lambda x: x[0])
    for name, obj in items:
        if stubgenc.is_c_function(obj):
            stubgenc.generate_c_function_stub(
                module, name, obj, functions, imports=imports, sigs=sigs
            )
            done.add(name)
    types = []  # type: List[str]
    for name, obj in items:
        if name.startswith("__") and name.endswith("__"):
            continue
        if stubgenc.is_c_type(obj):
            generate_c_type_stub(
                module,
                name,
                obj,
                types,
                imports=imports,
                sigs=sigs,
                class_sigs=class_sigs,
            )
            done.add(name)
    variables = []
    for name, obj in items:
        if name.startswith("__") and name.endswith("__"):
            continue
        if name not in done and not inspect.ismodule(obj):
            type_str = type(obj).__name__
            if type_str not in ("int", "str", "bytes", "float", "bool"):
                type_str = "Any"
            variables.append("%s: %s" % (name, type_str))
    output = []
    for line in sorted(set(imports)):
        output.append(line)
    for line in variables:
        output.append(line)
    if output and functions:
        output.append("")
    for line in functions:
        output.append(line)
    for line in types:
        if line.startswith("class") and output and output[-1]:
            output.append("")
        output.append(line)
    output = stubgenc.add_typing_import(output)
    with open(target, "w") as file:
        for line in output:
            file.write("%s\n" % line)


def main():
    parser = argparse.ArgumentParser(
        f"{os.path.basename(sys.executable)} -m edgedb.schema"
    )
    parser.add_argument("-I", "--instance")
    parser.add_argument("-n", "--namespace")
    args = parser.parse_args()

    conn = connect(args.instance)
    try:
        importer = EdgeDBModuleImporter(namespace=args.namespace).introspect(conn)
    finally:
        conn.close()

    if args.namespace:
        package = args.namespace
        mod = importlib.import_module(package)
        dir_name = pathlib.Path(mod.__file__).parent
        builtin = False
    else:
        package = __package__
        dir_name = pathlib.Path(__file__).parent
        builtin = True

    for name in importer.all(builtin=builtin):
        path = str(dir_name / f"{name}.pyi")
        print(f"Generating {path}")
        generate_stub_for_c_module(f"{package}.{name}", path)


if __name__ == "__main__":
    main()
